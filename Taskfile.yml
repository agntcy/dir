# Copyright AGNTCY Contributors (https://github.com/agntcy)
# SPDX-License-Identifier: Apache-2.0

version: "3"

env:
  GOWORK: off

includes:
  variables:
    taskfile: ./Taskfile.vars.yml
    dir: ./
    flatten: true
  deps:
    taskfile: ./bin/Taskfile.yml
    dir: ./bin
    flatten: true
  api:
    taskfile: ./api/Taskfile.yml
    dir: .
    flatten: true
  cli:
    taskfile: ./cli/Taskfile.yml
    dir: ./cli
    flatten: true
  e2e:
    taskfile: ./e2e/Taskfile.yml
    dir: ./e2e
    flatten: true
  gui:
    taskfile: ./gui/Taskfile.yml
    dir: ./gui
    flatten: true
  install:
    aliases: [deploy]
    taskfile: ./install/Taskfile.yml
    dir: ./install
    flatten: true
  mcp:
    taskfile: ./mcp/Taskfile.yml
    dir: ./mcp
    flatten: true
  runtime:
    taskfile: ./runtime/Taskfile.yml
    dir: ./runtime
    flatten: true
  sdk:
    taskfile: ./sdk/Taskfile.yml
    dir: ./sdk
    flatten: true
  server:
    taskfile: ./server/Taskfile.yml
    dir: ./server
    flatten: true

tasks:
  ##
  ## General
  ##
  default:
    cmds:
      - task -l

  gen:
    desc: Generate code for all components
    cmds:
      - task: api:gen
      - task: helm:gen

  check:
    desc: Checks for all code violations
    cmds:
      - task: lint
      - task: license

  build:
    desc: Build images for all components
    deps:
      - task: deps:tidy
      - task: gen
    vars:
      GOARCH: "{{ .GOARCH | default ARCH }}"
      EXTRA_FLAGS: '{{ .EXTRA_FLAGS | default "" }}'
    cmds:
      - "{{.BAKE_ENV}} docker buildx bake {{.IMAGE_BAKE_OPTS}} --set *.platform=linux/{{.GOARCH}} {{.EXTRA_FLAGS}}"

  build:coverage:
    desc: Build images for all components with coverage instrumentation
    cmds:
      - task: build
        vars:
          BAKE_ENV: "{{ .COVERAGE_BAKE_ENV }}"
          # TODO: -coverpkg should be set to include all packages (server, api, utils) in the coverage report
          # but it's not working as expected, so we're using the default coverage package for now
          EXTRA_FLAGS: 'coverage --set *.args.BUILD_OPTS="-cover -covermode=atomic"'

  build:all:
    desc: Build images for all components for multiple platforms
    cmds:
      - "{{.BAKE_ENV}} docker buildx bake {{.IMAGE_BAKE_OPTS}} --set *.platform=linux/amd64,linux/arm64"

  pull:
    desc: Pull images for all components
    cmds:
      - |
        images=$({{.BAKE_ENV}} docker buildx bake default --print | jq -r '.target | with_entries(.value |= .tags[0]) | to_entries[] | .value')
        echo "$images" | while read image; do
          echo "Pulling image: $image"
          docker pull $image
        done

  push:
    desc: Build and push images for all components
    prompt:
      - Are you sure you want to push the images to remote registry?
    cmds:
      - "{{.BAKE_ENV}} docker buildx bake {{.IMAGE_BAKE_OPTS}} --set=*.output=type=registry"

  release:create:
    desc: Prepare release
    deps:
      - task: deps:multimod-bin
      - task: sdk:deps:python
      - task: sdk:deps:javascript
    vars:
      RELEASE_VERSION: "{{ .RELEASE_VERSION }}"
    cmds:
      # Switch to new branch
      - 'if [ "$(git rev-parse --abbrev-ref HEAD)" != "release/{{.RELEASE_VERSION}}" ]; then git checkout -b release/{{.RELEASE_VERSION}}; fi'
      # Update versions.yaml with the new version
      - 'awk ''{gsub(/version: .*/,"version: {{.RELEASE_VERSION}}")}1'' versions.yaml > versions.yaml.tmp'
      - "mv versions.yaml.tmp versions.yaml"
      # Update SDK packages with the new version
      - "cd sdk/dir-py && {{ .UV_BIN }} version {{.RELEASE_VERSION}} && cd -"
      - "cd sdk/dir-js && npm version {{.RELEASE_VERSION}} --allow-same-version --no-git-tag-version && cd -"
      # Add release changes
      - |
        git add .
        git commit -S -m "release(dir): prepare release {{.RELEASE_VERSION}}"
      # Verify Go release
      - |
        {{ .MULTIMOD_BIN }} verify
        {{ .MULTIMOD_BIN }} prerelease --all-module-sets --skip-go-mod-tidy=true --commit-to-different-branch=false
      # Push prepared release
      - task: release:push

  release:push:
    internal: true
    vars:
      RELEASE_VERSION: "{{ .RELEASE_VERSION }}"
    prompt:
      - "Are you sure you want to push the release branch release/{{.RELEASE_VERSION}} to remote repository?"
    cmds:
      - |
        git push --set-upstream origin release/{{.RELEASE_VERSION}} || true

  ##
  ## Test
  ##
  test:unit:
    desc: Run unit tests on codebase
    aliases: [test]
    env:
      GOWORK: off
    vars:
      EXTRA_ARGS: '{{ .EXTRA_ARGS | default "" }}'
    cmds:
      - for: { var: GO_MOD_DIR_UNIT_TEST }
        cmd: |
          echo "Running tests in {{.ITEM}}"
          go -C {{.ITEM}} test ./... {{.EXTRA_ARGS}}

  test:unit:coverage:
    desc: Run all unit tests with coverage and generate summaries + HTML reports
    vars:
      COVERAGE_DIR: '{{ .COVERAGE_DIR | default (print .ROOT_DIR "/.coverage/unit") }}'
    cmds:
      - echo "Removing existing coverage directory and reports"
      - rm -rf {{.COVERAGE_DIR}}/*
      - echo "Creating new coverage directory"
      - mkdir -p {{.COVERAGE_DIR}}
      - |
        set -euo pipefail
        # Build list of modules from GO_MOD_DIR_UNIT_TEST
        modules=""
        {{range $dir := .GO_MOD_DIR_UNIT_TEST | splitList "\n"}}
        {{if $dir}}modules="$modules $(basename {{$dir}})"{{end}}
        {{end}}
        for m in $modules; do
          if [ -d "$m" ]; then
            echo "[coverage] Testing module: $m"
            (
              cd "$m"
              # Run tests with coverprofile (text format)
              if go test -covermode=atomic -coverprofile="{{.COVERAGE_DIR}}/$m.out.tmp" ./... -json 2>&1 | tee "{{.COVERAGE_DIR}}/test-report-$m.json" >/dev/null; then
                echo "[coverage] Completed: $m"
              else
                status=$?
                echo "[coverage][warn] Tests failed in $m (exit $status); continuing"
              fi
            )
            # Filter out generated files (matching codecov.yml ignores)
            if [ -f "{{.COVERAGE_DIR}}/$m.out.tmp" ]; then
              grep -v "\.pb\.go" "{{.COVERAGE_DIR}}/$m.out.tmp" | grep -v "mock_.*\.go" > "{{.COVERAGE_DIR}}/$m.out" || echo "mode: atomic" > "{{.COVERAGE_DIR}}/$m.out"
              rm "{{.COVERAGE_DIR}}/$m.out.tmp"
            else
              echo "[coverage] No coverage generated for $m"
              echo "mode: atomic" > "{{.COVERAGE_DIR}}/$m.out"
            fi
          fi
        done

      - |
        set -euo pipefail
        echo "[coverage] Generating per-module summaries"
        : > {{.COVERAGE_DIR}}/summary.txt
        # Build list of modules from GO_MOD_DIR_UNIT_TEST
        modules=""
        {{range $dir := .GO_MOD_DIR_UNIT_TEST | splitList "\n"}}
        {{if $dir}}modules="$modules $(basename {{$dir}})"{{end}}
        {{end}}
        for m in $modules; do
          if [ -f "{{.COVERAGE_DIR}}/$m.out" ]; then
            if (cd "$m" && go tool cover -func={{.COVERAGE_DIR}}/$m.out > {{.COVERAGE_DIR}}/$m.func.txt 2>/dev/null); then
              tail -n1 {{.COVERAGE_DIR}}/$m.func.txt | sed "s/^total:/[$m] total:/" >> {{.COVERAGE_DIR}}/summary.txt || true
            else
              echo "[$m] total: (error generating summary)" >> {{.COVERAGE_DIR}}/summary.txt
            fi
          fi
        done
        echo "[coverage] Summary:"; cat {{.COVERAGE_DIR}}/summary.txt

      - |
        set -euo pipefail
        echo "[coverage] Generating HTML reports"
        # Build list of modules from GO_MOD_DIR_UNIT_TEST
        modules=""
        {{range $dir := .GO_MOD_DIR_UNIT_TEST | splitList "\n"}}
        {{if $dir}}modules="$modules $(basename {{$dir}})"{{end}}
        {{end}}
        for m in $modules; do
          if [ -f "{{.COVERAGE_DIR}}/$m.out" ] && [ -d "$m" ]; then
            (cd "$m" && go tool cover -html={{.COVERAGE_DIR}}/$m.out -o {{.COVERAGE_DIR}}/$m.html || true)
          fi
        done
        echo "[coverage] Generated HTML files:"; ls -1 {{.COVERAGE_DIR}}/*.html 2>/dev/null | sed 's|{{.COVERAGE_DIR}}/|  - |' || echo "  (none)"

  bench:
    desc: Run bench tests on codebase
    cmds: # run in sequence
      - task: server:bench
      - echo "Done"

  ##
  ## Linters
  ##
  lint:go:
    desc: Run Golang linters
    deps:
      - task: deps:golangci-lint
    vars:
      FIX: '{{ .FIX | default "false" }}'
      FIX_FLAG: '{{if eq .FIX "true"}}--fix{{end}}'
    cmds:
      - for: { var: GO_MOD_DIR }
        cmd: |
          echo "Running golangci-lint in {{.ITEM}}"
          cd {{.ITEM}}
          {{.GOLANGCI_LINT_BIN}} run --config {{.ROOT_DIR}}/.golangci.yml {{.FIX_FLAG}}

  lint:buf:
    desc: Run Buf linters
    deps:
      - task: deps:protoc
      - task: deps:bufbuild
    dir: ./proto
    cmds:
      - "{{.BUFBUILD_BIN}} lint"

  lint:helm:
    desc: Run Helm linters
    deps:
      - task: deps:helm
    vars:
      HELM_CHARTS:
        sh: find ./install/charts -maxdepth 1 -mindepth 1 -type d -exec basename {} \;
    cmds:
      - for: { var: HELM_CHARTS }
        cmd: |
          echo "Running helm lint on {{.ITEM}}"
          {{.HELM_BIN}} dependency update ./install/charts/{{.ITEM}}
          {{.HELM_BIN}} lint ./install/charts/{{.ITEM}} --with-subcharts

  lint:
    desc: Run all linters
    deps:
      - lint:go
      - lint:buf
      - lint:helm

  ##
  ## License
  ##
  license:
    desc: Check licenses
    deps:
      - task: deps:licensei
    cmds:
      - for: { var: GO_MOD_DIR }
        cmd: echo "Running licensei in {{.ITEM}}" && cd {{.ITEM}} && {{ .LICENSEI_BIN }} check --config {{.ROOT_DIR}}/.licensei.toml

  license:cache:
    desc: Check licenses
    deps:
      - task: deps:licensei
    cmds:
      - for: { var: GO_MOD_DIR }
        cmd: echo "Running licensei in {{.ITEM}}" && cd {{.ITEM}} && {{ .LICENSEI_BIN }} cache --config {{.ROOT_DIR}}/.licensei.toml

  ##
  ## Various proof-of-concept tasks
  ##
  poc:integration:
    desc: Run integration against VS Code and Continue proof-of-concept.
    dir: ./docs/research/integrations
    prompt:
      - |
        Are you sure you want to run integration proof-of-concept?
        This will overwrite your local workspace VSCode and Continue configuration.
    vars:
      RECORD_FILE: '{{ .RECORD_FILE | default "docs/research/integrations/demo.record.json" }}'
    cmd: |
      # Prepare Python environment
      python3 -m venv venv
      . ./venv/bin/activate
      python3 -m pip install pyyaml

      # Run script
      python3 ./importer.py \
        -record={{.ROOT_DIR}}/{{.RECORD_FILE}} \
        -vscode_path={{.ROOT_DIR}}/.vscode \
        -continue_path={{.ROOT_DIR}}/.continue/assistants

      # Print env requirements
      cat .env.example

  poc:mcp-to-oasf:
    desc: Import MCP-to-OASF Exporter Agent into the current workspace.
    cmds:
      - task: poc:integration
        vars:
          RECORD_FILE: "docs/research/integrations/mcp-to-oasf-agent/extractor.record.json"
