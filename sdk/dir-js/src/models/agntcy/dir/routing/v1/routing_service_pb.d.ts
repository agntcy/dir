// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.9.0 with parameter "import_extension=js"
// @generated from file agntcy/dir/routing/v1/routing_service.proto (package agntcy.dir.routing.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { RecordRef } from "../../core/v1/record_pb.js";
import type { RecordQuery } from "../../search/v1/record_query_pb.js";
import type { RecordQuery as RecordQuery$1 } from "./record_query_pb.js";
import type { Peer } from "./peer_pb.js";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file agntcy/dir/routing/v1/routing_service.proto.
 */
export declare const file_agntcy_dir_routing_v1_routing_service: GenFile;

/**
 * @generated from message agntcy.dir.routing.v1.PublishRequest
 */
export declare type PublishRequest = Message<"agntcy.dir.routing.v1.PublishRequest"> & {
  /**
   * @generated from oneof agntcy.dir.routing.v1.PublishRequest.request
   */
  request: {
    /**
     * References to the records to be published.
     *
     * @generated from field: agntcy.dir.routing.v1.RecordRefs record_refs = 1;
     */
    value: RecordRefs;
    case: "recordRefs";
  } | {
    /**
     * Queries to match against the records to be published.
     *
     * @generated from field: agntcy.dir.routing.v1.RecordQueries queries = 2;
     */
    value: RecordQueries;
    case: "queries";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message agntcy.dir.routing.v1.PublishRequest.
 * Use `create(PublishRequestSchema)` to create a new message.
 */
export declare const PublishRequestSchema: GenMessage<PublishRequest>;

/**
 * @generated from message agntcy.dir.routing.v1.UnpublishRequest
 */
export declare type UnpublishRequest = Message<"agntcy.dir.routing.v1.UnpublishRequest"> & {
  /**
   * @generated from oneof agntcy.dir.routing.v1.UnpublishRequest.request
   */
  request: {
    /**
     * References to the records to be unpublished.
     *
     * @generated from field: agntcy.dir.routing.v1.RecordRefs record_refs = 1;
     */
    value: RecordRefs;
    case: "recordRefs";
  } | {
    /**
     * Queries to match against the records to be unpublished.
     *
     * @generated from field: agntcy.dir.routing.v1.RecordQueries queries = 2;
     */
    value: RecordQueries;
    case: "queries";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message agntcy.dir.routing.v1.UnpublishRequest.
 * Use `create(UnpublishRequestSchema)` to create a new message.
 */
export declare const UnpublishRequestSchema: GenMessage<UnpublishRequest>;

/**
 * @generated from message agntcy.dir.routing.v1.RecordRefs
 */
export declare type RecordRefs = Message<"agntcy.dir.routing.v1.RecordRefs"> & {
  /**
   * @generated from field: repeated agntcy.dir.core.v1.RecordRef refs = 1;
   */
  refs: RecordRef[];
};

/**
 * Describes the message agntcy.dir.routing.v1.RecordRefs.
 * Use `create(RecordRefsSchema)` to create a new message.
 */
export declare const RecordRefsSchema: GenMessage<RecordRefs>;

/**
 * @generated from message agntcy.dir.routing.v1.RecordQueries
 */
export declare type RecordQueries = Message<"agntcy.dir.routing.v1.RecordQueries"> & {
  /**
   * @generated from field: repeated agntcy.dir.search.v1.RecordQuery queries = 1;
   */
  queries: RecordQuery[];
};

/**
 * Describes the message agntcy.dir.routing.v1.RecordQueries.
 * Use `create(RecordQueriesSchema)` to create a new message.
 */
export declare const RecordQueriesSchema: GenMessage<RecordQueries>;

/**
 * @generated from message agntcy.dir.routing.v1.SearchRequest
 */
export declare type SearchRequest = Message<"agntcy.dir.routing.v1.SearchRequest"> & {
  /**
   * List of queries to match against the records.
   *
   * @generated from field: repeated agntcy.dir.routing.v1.RecordQuery queries = 1;
   */
  queries: RecordQuery$1[];

  /**
   * Minimal target query match score.
   * For example, if min_match_score=2, it will return records that match
   * at least two of the queries.
   * If not set, it will return records that match at least one query.
   *
   * @generated from field: optional uint32 min_match_score = 2;
   */
  minMatchScore?: number;

  /**
   * Limit the number of results returned.
   * If not set, it will return all discovered records.
   * Note that this is a soft limit, as the search may return more results
   * than the limit if there are multiple peers providing the same record.
   *
   * @generated from field: optional uint32 limit = 3;
   */
  limit?: number;
};

/**
 * Describes the message agntcy.dir.routing.v1.SearchRequest.
 * Use `create(SearchRequestSchema)` to create a new message.
 */
export declare const SearchRequestSchema: GenMessage<SearchRequest>;

/**
 * @generated from message agntcy.dir.routing.v1.SearchResponse
 */
export declare type SearchResponse = Message<"agntcy.dir.routing.v1.SearchResponse"> & {
  /**
   * The record that matches the search query.
   *
   * @generated from field: agntcy.dir.core.v1.RecordRef record_ref = 1;
   */
  recordRef?: RecordRef;

  /**
   * The peer that provided the record.
   *
   * @generated from field: agntcy.dir.routing.v1.Peer peer = 2;
   */
  peer?: Peer;

  /**
   * The queries that were matched.
   *
   * @generated from field: repeated agntcy.dir.routing.v1.RecordQuery match_queries = 3;
   */
  matchQueries: RecordQuery$1[];

  /**
   * The score of the search match.
   *
   * @generated from field: uint32 match_score = 4;
   */
  matchScore: number;
};

/**
 * Describes the message agntcy.dir.routing.v1.SearchResponse.
 * Use `create(SearchResponseSchema)` to create a new message.
 */
export declare const SearchResponseSchema: GenMessage<SearchResponse>;

/**
 * @generated from message agntcy.dir.routing.v1.ListRequest
 */
export declare type ListRequest = Message<"agntcy.dir.routing.v1.ListRequest"> & {
  /**
   * List of queries to match against the records.
   * If set, all queries must match for the record to be returned.
   *
   * @generated from field: repeated agntcy.dir.routing.v1.RecordQuery queries = 1;
   */
  queries: RecordQuery$1[];

  /**
   * Limit the number of results returned.
   * If not set, it will return all records that this peer is providing.
   *
   * @generated from field: optional uint32 limit = 2;
   */
  limit?: number;
};

/**
 * Describes the message agntcy.dir.routing.v1.ListRequest.
 * Use `create(ListRequestSchema)` to create a new message.
 */
export declare const ListRequestSchema: GenMessage<ListRequest>;

/**
 * @generated from message agntcy.dir.routing.v1.ListResponse
 */
export declare type ListResponse = Message<"agntcy.dir.routing.v1.ListResponse"> & {
  /**
   * The record that matches the list queries.
   *
   * @generated from field: agntcy.dir.core.v1.RecordRef record_ref = 1;
   */
  recordRef?: RecordRef;

  /**
   * Labels associated with this record (skills, domains, modules)
   * Derived from the record content for CLI display purposes
   *
   * @generated from field: repeated string labels = 2;
   */
  labels: string[];
};

/**
 * Describes the message agntcy.dir.routing.v1.ListResponse.
 * Use `create(ListResponseSchema)` to create a new message.
 */
export declare const ListResponseSchema: GenMessage<ListResponse>;

/**
 * Defines an interface for announcement and discovery
 * of records across interconnected network.
 *
 * Middleware should be used to control who can perform these RPCs.
 * Policies for the middleware can be handled via separate service.
 *
 * @generated from service agntcy.dir.routing.v1.RoutingService
 */
export declare const RoutingService: GenService<{
  /**
   * Announce to the network that this peer is providing a given record.
   * This enables other peers to discover this record and retrieve it
   * from this peer. Listeners can use this event to perform custom operations,
   * for example by cloning the record.
   *
   * Items need to be periodically republished (eg. 24h) to the network
   * to avoid stale data. Republication should be done in the background.
   *
   * @generated from rpc agntcy.dir.routing.v1.RoutingService.Publish
   */
  publish: {
    methodKind: "unary";
    input: typeof PublishRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Stop serving this record to the network. If other peers try
   * to retrieve this record, the peer will refuse the request.
   *
   * @generated from rpc agntcy.dir.routing.v1.RoutingService.Unpublish
   */
  unpublish: {
    methodKind: "unary";
    input: typeof UnpublishRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Search records based on the request across the network.
   * This will search the network for the record with the given parameters.
   *
   * It is possible that the records are stale or that they do not exist.
   * Some records may be provided by multiple peers.
   *
   * Results from the search can be used as an input
   * to Pull operation to retrieve the records.
   *
   * @generated from rpc agntcy.dir.routing.v1.RoutingService.Search
   */
  search: {
    methodKind: "server_streaming";
    input: typeof SearchRequestSchema;
    output: typeof SearchResponseSchema;
  },
  /**
   * List all records that this peer is currently providing
   * that match the given parameters.
   * This operation does not interact with the network.
   *
   * @generated from rpc agntcy.dir.routing.v1.RoutingService.List
   */
  list: {
    methodKind: "server_streaming";
    input: typeof ListRequestSchema;
    output: typeof ListResponseSchema;
  },
}>;

