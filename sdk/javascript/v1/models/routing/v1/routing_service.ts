// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "routing/v1/routing_service.proto" (package "routing.v1", syntax proto3)
// tslint:disable
//
// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0
//
import { Empty } from "../../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Peer } from "./peer";
import { RecordQuery as RecordQuery$ } from "./record_query";
import { RecordQuery } from "../../search/v1/record_query";
import { RecordRef } from "../../core/v1/record";
/**
 * @generated from protobuf message routing.v1.PublishRequest
 */
export interface PublishRequest {
    /**
     * @generated from protobuf oneof: request
     */
    request: {
        oneofKind: "recordRefs";
        /**
         * References to the records to be published.
         *
         * @generated from protobuf field: routing.v1.RecordRefs record_refs = 1
         */
        recordRefs: RecordRefs;
    } | {
        oneofKind: "queries";
        /**
         * Queries to match against the records to be published.
         *
         * @generated from protobuf field: routing.v1.RecordQueries queries = 2
         */
        queries: RecordQueries;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message routing.v1.UnpublishRequest
 */
export interface UnpublishRequest {
    /**
     * @generated from protobuf oneof: request
     */
    request: {
        oneofKind: "recordRefs";
        /**
         * References to the records to be unpublished.
         *
         * @generated from protobuf field: routing.v1.RecordRefs record_refs = 1
         */
        recordRefs: RecordRefs;
    } | {
        oneofKind: "queries";
        /**
         * Queries to match against the records to be unpublished.
         *
         * @generated from protobuf field: routing.v1.RecordQueries queries = 2
         */
        queries: RecordQueries;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message routing.v1.RecordRefs
 */
export interface RecordRefs {
    /**
     * @generated from protobuf field: repeated core.v1.RecordRef refs = 1
     */
    refs: RecordRef[];
}
/**
 * @generated from protobuf message routing.v1.RecordQueries
 */
export interface RecordQueries {
    /**
     * @generated from protobuf field: repeated search.v1.RecordQuery queries = 1
     */
    queries: RecordQuery[];
}
/**
 * @generated from protobuf message routing.v1.SearchRequest
 */
export interface SearchRequest {
    /**
     * List of queries to match against the records.
     *
     * @generated from protobuf field: repeated routing.v1.RecordQuery queries = 1
     */
    queries: RecordQuery$[];
    /**
     * Minimal target query match score.
     * For example, if min_match_score=2, it will return records that match
     * at least two of the queries.
     * If not set, it will return records that match at least one query.
     *
     * @generated from protobuf field: optional uint32 min_match_score = 2
     */
    minMatchScore?: number;
    /**
     * Limit the number of results returned.
     * If not set, it will return all discovered records.
     * Note that this is a soft limit, as the search may return more results
     * than the limit if there are multiple peers providing the same record.
     *
     * @generated from protobuf field: optional uint32 limit = 3
     */
    limit?: number;
}
/**
 * @generated from protobuf message routing.v1.SearchResponse
 */
export interface SearchResponse {
    /**
     * The record that matches the search query.
     *
     * @generated from protobuf field: string record_cid = 1
     */
    recordCid: string;
    /**
     * The peer that provided the record.
     *
     * @generated from protobuf field: routing.v1.Peer peer = 2
     */
    peer?: Peer;
    /**
     * The queries that were matched.
     *
     * @generated from protobuf field: repeated routing.v1.RecordQuery match_queries = 3
     */
    matchQueries: RecordQuery$[];
    /**
     * The score of the search match.
     *
     * @generated from protobuf field: uint32 match_score = 4
     */
    matchScore: number;
}
/**
 * @generated from protobuf message routing.v1.ListRequest
 */
export interface ListRequest {
    /**
     * List of queries to match against the records.
     * If set, all queries must match for the record to be returned.
     *
     * @generated from protobuf field: repeated routing.v1.RecordQuery queries = 1
     */
    queries: RecordQuery$[];
    /**
     * Limit the number of results returned.
     * If not set, it will return all records that this peer is providing.
     *
     * @generated from protobuf field: optional uint32 limit = 2
     */
    limit?: number;
    /**
     * Legacy list request.
     * TODO Remove when new announce and discovery design is implemented
     *
     * @generated from protobuf field: optional routing.v1.LegacyListRequest legacy_list_request = 3
     */
    legacyListRequest?: LegacyListRequest;
}
/**
 * @generated from protobuf message routing.v1.LegacyListRequest
 */
export interface LegacyListRequest {
    /**
     * Target peer.
     * If selected, it returns the skill details for this peer.
     * It may use labels to only return selected labels.
     *
     * @generated from protobuf field: optional routing.v1.Peer peer = 1
     */
    peer?: Peer;
    /**
     * Target labels.
     * For example, labels={"skill=text", "skill=text/rag"}
     *
     * @generated from protobuf field: repeated string labels = 2
     */
    labels: string[];
    /**
     * Target record, if any.
     * If set, it will return only the record with the given reference.
     *
     * @generated from protobuf field: optional core.v1.RecordRef ref = 3
     */
    ref?: RecordRef;
    /**
     * Max routing depth.
     *
     * @generated from protobuf field: optional uint32 max_hops = 4
     */
    maxHops?: number;
}
/**
 * @generated from protobuf message routing.v1.ListResponse
 */
export interface ListResponse {
    /**
     * The record that matches the list queries.
     *
     * @generated from protobuf field: string record_cid = 1
     */
    recordCid: string;
    /**
     * Legacy list response.
     * TODO Remove when new announce and discovery design is implemented
     *
     * @generated from protobuf field: optional routing.v1.LegacyListResponse legacy_list_response = 2
     */
    legacyListResponse?: LegacyListResponse;
}
/**
 * @generated from protobuf message routing.v1.LegacyListResponse
 */
export interface LegacyListResponse {
    /**
     * Returned items that match a given request
     *
     * @generated from protobuf field: repeated routing.v1.LegacyListResponse.Item items = 1
     */
    items: LegacyListResponse_Item[];
}
/**
 * @generated from protobuf message routing.v1.LegacyListResponse.Item
 */
export interface LegacyListResponse_Item {
    /**
     * Labels associated with a given record
     *
     * @generated from protobuf field: repeated string labels = 1
     */
    labels: string[];
    /**
     * Optionally sends count details about individual skill.
     * This is only set when querying labels or our own current peer.
     * For record requests, only returns the data about that record.
     *
     * @generated from protobuf field: map<string, uint64> label_counts = 2
     */
    labelCounts: {
        [key: string]: bigint;
    };
    /**
     * Peer that returned this record.
     *
     * @generated from protobuf field: routing.v1.Peer peer = 3
     */
    peer?: Peer;
    /**
     * Found record if any.
     * If empty, then only the labels are important.
     *
     * @generated from protobuf field: optional core.v1.RecordRef ref = 4
     */
    ref?: RecordRef;
}
// @generated message type with reflection information, may provide speed optimized methods
class PublishRequest$Type extends MessageType<PublishRequest> {
    constructor() {
        super("routing.v1.PublishRequest", [
            { no: 1, name: "record_refs", kind: "message", oneof: "request", T: () => RecordRefs },
            { no: 2, name: "queries", kind: "message", oneof: "request", T: () => RecordQueries }
        ]);
    }
    create(value?: PartialMessage<PublishRequest>): PublishRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PublishRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRequest): PublishRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routing.v1.RecordRefs record_refs */ 1:
                    message.request = {
                        oneofKind: "recordRefs",
                        recordRefs: RecordRefs.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).recordRefs)
                    };
                    break;
                case /* routing.v1.RecordQueries queries */ 2:
                    message.request = {
                        oneofKind: "queries",
                        queries: RecordQueries.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).queries)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routing.v1.RecordRefs record_refs = 1; */
        if (message.request.oneofKind === "recordRefs")
            RecordRefs.internalBinaryWrite(message.request.recordRefs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routing.v1.RecordQueries queries = 2; */
        if (message.request.oneofKind === "queries")
            RecordQueries.internalBinaryWrite(message.request.queries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.PublishRequest
 */
export const PublishRequest = new PublishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnpublishRequest$Type extends MessageType<UnpublishRequest> {
    constructor() {
        super("routing.v1.UnpublishRequest", [
            { no: 1, name: "record_refs", kind: "message", oneof: "request", T: () => RecordRefs },
            { no: 2, name: "queries", kind: "message", oneof: "request", T: () => RecordQueries }
        ]);
    }
    create(value?: PartialMessage<UnpublishRequest>): UnpublishRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UnpublishRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnpublishRequest): UnpublishRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* routing.v1.RecordRefs record_refs */ 1:
                    message.request = {
                        oneofKind: "recordRefs",
                        recordRefs: RecordRefs.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).recordRefs)
                    };
                    break;
                case /* routing.v1.RecordQueries queries */ 2:
                    message.request = {
                        oneofKind: "queries",
                        queries: RecordQueries.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).queries)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnpublishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* routing.v1.RecordRefs record_refs = 1; */
        if (message.request.oneofKind === "recordRefs")
            RecordRefs.internalBinaryWrite(message.request.recordRefs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* routing.v1.RecordQueries queries = 2; */
        if (message.request.oneofKind === "queries")
            RecordQueries.internalBinaryWrite(message.request.queries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.UnpublishRequest
 */
export const UnpublishRequest = new UnpublishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordRefs$Type extends MessageType<RecordRefs> {
    constructor() {
        super("routing.v1.RecordRefs", [
            { no: 1, name: "refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordRef }
        ]);
    }
    create(value?: PartialMessage<RecordRefs>): RecordRefs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refs = [];
        if (value !== undefined)
            reflectionMergePartial<RecordRefs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordRefs): RecordRefs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated core.v1.RecordRef refs */ 1:
                    message.refs.push(RecordRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordRefs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated core.v1.RecordRef refs = 1; */
        for (let i = 0; i < message.refs.length; i++)
            RecordRef.internalBinaryWrite(message.refs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.RecordRefs
 */
export const RecordRefs = new RecordRefs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordQueries$Type extends MessageType<RecordQueries> {
    constructor() {
        super("routing.v1.RecordQueries", [
            { no: 1, name: "queries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordQuery }
        ]);
    }
    create(value?: PartialMessage<RecordQueries>): RecordQueries {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queries = [];
        if (value !== undefined)
            reflectionMergePartial<RecordQueries>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordQueries): RecordQueries {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated search.v1.RecordQuery queries */ 1:
                    message.queries.push(RecordQuery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordQueries, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated search.v1.RecordQuery queries = 1; */
        for (let i = 0; i < message.queries.length; i++)
            RecordQuery.internalBinaryWrite(message.queries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.RecordQueries
 */
export const RecordQueries = new RecordQueries$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor() {
        super("routing.v1.SearchRequest", [
            { no: 1, name: "queries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordQuery$ },
            { no: 2, name: "min_match_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SearchRequest>): SearchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queries = [];
        if (value !== undefined)
            reflectionMergePartial<SearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routing.v1.RecordQuery queries */ 1:
                    message.queries.push(RecordQuery$.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 min_match_score */ 2:
                    message.minMatchScore = reader.uint32();
                    break;
                case /* optional uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated routing.v1.RecordQuery queries = 1; */
        for (let i = 0; i < message.queries.length; i++)
            RecordQuery$.internalBinaryWrite(message.queries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 min_match_score = 2; */
        if (message.minMatchScore !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.minMatchScore);
        /* optional uint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.SearchRequest
 */
export const SearchRequest = new SearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchResponse$Type extends MessageType<SearchResponse> {
    constructor() {
        super("routing.v1.SearchResponse", [
            { no: 1, name: "record_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peer", kind: "message", T: () => Peer },
            { no: 3, name: "match_queries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordQuery$ },
            { no: 4, name: "match_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SearchResponse>): SearchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recordCid = "";
        message.matchQueries = [];
        message.matchScore = 0;
        if (value !== undefined)
            reflectionMergePartial<SearchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string record_cid */ 1:
                    message.recordCid = reader.string();
                    break;
                case /* routing.v1.Peer peer */ 2:
                    message.peer = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peer);
                    break;
                case /* repeated routing.v1.RecordQuery match_queries */ 3:
                    message.matchQueries.push(RecordQuery$.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 match_score */ 4:
                    message.matchScore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string record_cid = 1; */
        if (message.recordCid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recordCid);
        /* routing.v1.Peer peer = 2; */
        if (message.peer)
            Peer.internalBinaryWrite(message.peer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated routing.v1.RecordQuery match_queries = 3; */
        for (let i = 0; i < message.matchQueries.length; i++)
            RecordQuery$.internalBinaryWrite(message.matchQueries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 match_score = 4; */
        if (message.matchScore !== 0)
            writer.tag(4, WireType.Varint).uint32(message.matchScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.SearchResponse
 */
export const SearchResponse = new SearchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRequest$Type extends MessageType<ListRequest> {
    constructor() {
        super("routing.v1.ListRequest", [
            { no: 1, name: "queries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordQuery$ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "legacy_list_request", kind: "message", T: () => LegacyListRequest }
        ]);
    }
    create(value?: PartialMessage<ListRequest>): ListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queries = [];
        if (value !== undefined)
            reflectionMergePartial<ListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRequest): ListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routing.v1.RecordQuery queries */ 1:
                    message.queries.push(RecordQuery$.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                case /* optional routing.v1.LegacyListRequest legacy_list_request */ 3:
                    message.legacyListRequest = LegacyListRequest.internalBinaryRead(reader, reader.uint32(), options, message.legacyListRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated routing.v1.RecordQuery queries = 1; */
        for (let i = 0; i < message.queries.length; i++)
            RecordQuery$.internalBinaryWrite(message.queries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        /* optional routing.v1.LegacyListRequest legacy_list_request = 3; */
        if (message.legacyListRequest)
            LegacyListRequest.internalBinaryWrite(message.legacyListRequest, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.ListRequest
 */
export const ListRequest = new ListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegacyListRequest$Type extends MessageType<LegacyListRequest> {
    constructor() {
        super("routing.v1.LegacyListRequest", [
            { no: 1, name: "peer", kind: "message", T: () => Peer },
            { no: 2, name: "labels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ref", kind: "message", T: () => RecordRef },
            { no: 4, name: "max_hops", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LegacyListRequest>): LegacyListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = [];
        if (value !== undefined)
            reflectionMergePartial<LegacyListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LegacyListRequest): LegacyListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional routing.v1.Peer peer */ 1:
                    message.peer = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peer);
                    break;
                case /* repeated string labels */ 2:
                    message.labels.push(reader.string());
                    break;
                case /* optional core.v1.RecordRef ref */ 3:
                    message.ref = RecordRef.internalBinaryRead(reader, reader.uint32(), options, message.ref);
                    break;
                case /* optional uint32 max_hops */ 4:
                    message.maxHops = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LegacyListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional routing.v1.Peer peer = 1; */
        if (message.peer)
            Peer.internalBinaryWrite(message.peer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string labels = 2; */
        for (let i = 0; i < message.labels.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.labels[i]);
        /* optional core.v1.RecordRef ref = 3; */
        if (message.ref)
            RecordRef.internalBinaryWrite(message.ref, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 max_hops = 4; */
        if (message.maxHops !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.maxHops);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.LegacyListRequest
 */
export const LegacyListRequest = new LegacyListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListResponse$Type extends MessageType<ListResponse> {
    constructor() {
        super("routing.v1.ListResponse", [
            { no: 1, name: "record_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "legacy_list_response", kind: "message", T: () => LegacyListResponse }
        ]);
    }
    create(value?: PartialMessage<ListResponse>): ListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recordCid = "";
        if (value !== undefined)
            reflectionMergePartial<ListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListResponse): ListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string record_cid */ 1:
                    message.recordCid = reader.string();
                    break;
                case /* optional routing.v1.LegacyListResponse legacy_list_response */ 2:
                    message.legacyListResponse = LegacyListResponse.internalBinaryRead(reader, reader.uint32(), options, message.legacyListResponse);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string record_cid = 1; */
        if (message.recordCid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recordCid);
        /* optional routing.v1.LegacyListResponse legacy_list_response = 2; */
        if (message.legacyListResponse)
            LegacyListResponse.internalBinaryWrite(message.legacyListResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.ListResponse
 */
export const ListResponse = new ListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegacyListResponse$Type extends MessageType<LegacyListResponse> {
    constructor() {
        super("routing.v1.LegacyListResponse", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LegacyListResponse_Item }
        ]);
    }
    create(value?: PartialMessage<LegacyListResponse>): LegacyListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<LegacyListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LegacyListResponse): LegacyListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated routing.v1.LegacyListResponse.Item items */ 1:
                    message.items.push(LegacyListResponse_Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LegacyListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated routing.v1.LegacyListResponse.Item items = 1; */
        for (let i = 0; i < message.items.length; i++)
            LegacyListResponse_Item.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.LegacyListResponse
 */
export const LegacyListResponse = new LegacyListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegacyListResponse_Item$Type extends MessageType<LegacyListResponse_Item> {
    constructor() {
        super("routing.v1.LegacyListResponse.Item", [
            { no: 1, name: "labels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label_counts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 3, name: "peer", kind: "message", T: () => Peer },
            { no: 4, name: "ref", kind: "message", T: () => RecordRef }
        ]);
    }
    create(value?: PartialMessage<LegacyListResponse_Item>): LegacyListResponse_Item {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = [];
        message.labelCounts = {};
        if (value !== undefined)
            reflectionMergePartial<LegacyListResponse_Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LegacyListResponse_Item): LegacyListResponse_Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string labels */ 1:
                    message.labels.push(reader.string());
                    break;
                case /* map<string, uint64> label_counts */ 2:
                    this.binaryReadMap2(message.labelCounts, reader, options);
                    break;
                case /* routing.v1.Peer peer */ 3:
                    message.peer = Peer.internalBinaryRead(reader, reader.uint32(), options, message.peer);
                    break;
                case /* optional core.v1.RecordRef ref */ 4:
                    message.ref = RecordRef.internalBinaryRead(reader, reader.uint32(), options, message.ref);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: LegacyListResponse_Item["labelCounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LegacyListResponse_Item["labelCounts"] | undefined, val: LegacyListResponse_Item["labelCounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for routing.v1.LegacyListResponse.Item.label_counts");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: LegacyListResponse_Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string labels = 1; */
        for (let i = 0; i < message.labels.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.labels[i]);
        /* map<string, uint64> label_counts = 2; */
        for (let k of globalThis.Object.keys(message.labelCounts))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.labelCounts[k]).join();
        /* routing.v1.Peer peer = 3; */
        if (message.peer)
            Peer.internalBinaryWrite(message.peer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional core.v1.RecordRef ref = 4; */
        if (message.ref)
            RecordRef.internalBinaryWrite(message.ref, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message routing.v1.LegacyListResponse.Item
 */
export const LegacyListResponse_Item = new LegacyListResponse_Item$Type();
/**
 * @generated ServiceType for protobuf service routing.v1.RoutingService
 */
export const RoutingService = new ServiceType("routing.v1.RoutingService", [
    { name: "Publish", options: {}, I: PublishRequest, O: Empty },
    { name: "Unpublish", options: {}, I: UnpublishRequest, O: Empty },
    { name: "Search", serverStreaming: true, options: {}, I: SearchRequest, O: SearchResponse },
    { name: "List", serverStreaming: true, options: {}, I: ListRequest, O: ListResponse }
]);
