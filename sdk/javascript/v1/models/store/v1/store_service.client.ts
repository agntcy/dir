// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "store/v1/store_service.proto" (package "store.v1", syntax proto3)
// tslint:disable
//
// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { StoreService } from "./store_service";
import type { PullReferrerResponse } from "./store_service";
import type { PullReferrerRequest } from "./store_service";
import type { PushReferrerResponse } from "./store_service";
import type { PushReferrerRequest } from "./store_service";
import type { Empty } from "../../google/protobuf/empty";
import type { ClientStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RecordMeta } from "../../core/v1/record";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { RecordRef } from "../../core/v1/record";
import type { Record } from "../../core/v1/record";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Defines an interface for content-addressable storage
 * service for objects.
 *
 * Max object size: 4MB (to fully fit in a single request)
 * Max metadata size: 100KB
 *
 * Store service can be implemented by various storage backends,
 * such as local file system, OCI registry, etc.
 *
 * Middleware should be used to control who can perform these RPCs.
 * Policies for the middleware can be handled via separate service.
 *
 * Each operation is performed sequentially, meaning that
 * for the N-th request, N-th response will be returned.
 * If an error occurs, the stream will be cancelled.
 *
 * @generated from protobuf service store.v1.StoreService
 */
export interface IStoreServiceClient {
    /**
     * Push performs write operation for given records.
     *
     * @generated from protobuf rpc: Push
     */
    push(options?: RpcOptions): DuplexStreamingCall<Record, RecordRef>;
    /**
     * Pull performs read operation for given records.
     *
     * @generated from protobuf rpc: Pull
     */
    pull(options?: RpcOptions): DuplexStreamingCall<RecordRef, Record>;
    /**
     * Lookup resolves basic metadata for the records.
     *
     * @generated from protobuf rpc: Lookup
     */
    lookup(options?: RpcOptions): DuplexStreamingCall<RecordRef, RecordMeta>;
    /**
     * Remove performs delete operation for the records.
     *
     * @generated from protobuf rpc: Delete
     */
    delete(options?: RpcOptions): ClientStreamingCall<RecordRef, Empty>;
    /**
     * PushReferrer performs write operation for record referrers.
     *
     * @generated from protobuf rpc: PushReferrer
     */
    pushReferrer(options?: RpcOptions): DuplexStreamingCall<PushReferrerRequest, PushReferrerResponse>;
    /**
     * PullReferrer performs read operation for record referrers.
     *
     * @generated from protobuf rpc: PullReferrer
     */
    pullReferrer(options?: RpcOptions): DuplexStreamingCall<PullReferrerRequest, PullReferrerResponse>;
}
/**
 * Defines an interface for content-addressable storage
 * service for objects.
 *
 * Max object size: 4MB (to fully fit in a single request)
 * Max metadata size: 100KB
 *
 * Store service can be implemented by various storage backends,
 * such as local file system, OCI registry, etc.
 *
 * Middleware should be used to control who can perform these RPCs.
 * Policies for the middleware can be handled via separate service.
 *
 * Each operation is performed sequentially, meaning that
 * for the N-th request, N-th response will be returned.
 * If an error occurs, the stream will be cancelled.
 *
 * @generated from protobuf service store.v1.StoreService
 */
export class StoreServiceClient implements IStoreServiceClient, ServiceInfo {
    typeName = StoreService.typeName;
    methods = StoreService.methods;
    options = StoreService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Push performs write operation for given records.
     *
     * @generated from protobuf rpc: Push
     */
    push(options?: RpcOptions): DuplexStreamingCall<Record, RecordRef> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<Record, RecordRef>("duplex", this._transport, method, opt);
    }
    /**
     * Pull performs read operation for given records.
     *
     * @generated from protobuf rpc: Pull
     */
    pull(options?: RpcOptions): DuplexStreamingCall<RecordRef, Record> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<RecordRef, Record>("duplex", this._transport, method, opt);
    }
    /**
     * Lookup resolves basic metadata for the records.
     *
     * @generated from protobuf rpc: Lookup
     */
    lookup(options?: RpcOptions): DuplexStreamingCall<RecordRef, RecordMeta> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<RecordRef, RecordMeta>("duplex", this._transport, method, opt);
    }
    /**
     * Remove performs delete operation for the records.
     *
     * @generated from protobuf rpc: Delete
     */
    delete(options?: RpcOptions): ClientStreamingCall<RecordRef, Empty> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<RecordRef, Empty>("clientStreaming", this._transport, method, opt);
    }
    /**
     * PushReferrer performs write operation for record referrers.
     *
     * @generated from protobuf rpc: PushReferrer
     */
    pushReferrer(options?: RpcOptions): DuplexStreamingCall<PushReferrerRequest, PushReferrerResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<PushReferrerRequest, PushReferrerResponse>("duplex", this._transport, method, opt);
    }
    /**
     * PullReferrer performs read operation for record referrers.
     *
     * @generated from protobuf rpc: PullReferrer
     */
    pullReferrer(options?: RpcOptions): DuplexStreamingCall<PullReferrerRequest, PullReferrerResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<PullReferrerRequest, PullReferrerResponse>("duplex", this._transport, method, opt);
    }
}
