// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "store/v1/sync_service.proto" (package "store.v1", syntax proto3)
// tslint:disable
//
// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * CreateSyncRequest defines the parameters for creating a new synchronization operation.
 *
 * Currently supports basic synchronization of all objects from a remote Directory.
 * Future versions may include additional options for filtering and scheduling capabilities.
 *
 * @generated from protobuf message store.v1.CreateSyncRequest
 */
export interface CreateSyncRequest {
    /**
     * URL of the remote Registry to synchronize from.
     *
     * This should be a complete URL including protocol and port if non-standard.
     * Examples:
     * - "https://directory.example.com"
     * - "http://localhost:8080"
     * - "https://directory.example.com:9443"
     *
     * @generated from protobuf field: string remote_directory_url = 1
     */
    remoteDirectoryUrl: string;
}
/**
 * CreateSyncResponse contains the result of creating a new synchronization operation.
 *
 * @generated from protobuf message store.v1.CreateSyncResponse
 */
export interface CreateSyncResponse {
    /**
     * Unique identifier for the created synchronization operation.
     * This ID can be used with other SyncService RPCs to monitor and manage the sync.
     *
     * @generated from protobuf field: string sync_id = 1
     */
    syncId: string;
}
/**
 * ListSyncsRequest specifies parameters for listing synchronization operations.
 *
 * @generated from protobuf message store.v1.ListSyncsRequest
 */
export interface ListSyncsRequest {
    /**
     * Optional limit on the number of results to return.
     *
     * @generated from protobuf field: optional uint32 limit = 2
     */
    limit?: number;
    /**
     * Optional offset for pagination of results.
     *
     * @generated from protobuf field: optional uint32 offset = 3
     */
    offset?: number;
}
/**
 * ListSyncItem represents a single synchronization in the list of all syncs.
 *
 * @generated from protobuf message store.v1.ListSyncsItem
 */
export interface ListSyncsItem {
    /**
     * Unique identifier of the synchronization operation.
     *
     * @generated from protobuf field: string sync_id = 1
     */
    syncId: string;
    /**
     * Current status of the synchronization operation.
     *
     * @generated from protobuf field: store.v1.SyncStatus status = 2
     */
    status: SyncStatus;
    /**
     * URL of the remote Directory being synchronized from.
     *
     * @generated from protobuf field: string remote_directory_url = 3
     */
    remoteDirectoryUrl: string;
}
/**
 * GetSyncRequest specifies which synchronization status to retrieve.
 *
 * @generated from protobuf message store.v1.GetSyncRequest
 */
export interface GetSyncRequest {
    /**
     * Unique identifier of the synchronization operation to query.
     *
     * @generated from protobuf field: string sync_id = 1
     */
    syncId: string;
}
/**
 * GetSyncResponse provides detailed information about a specific synchronization operation.
 *
 * @generated from protobuf message store.v1.GetSyncResponse
 */
export interface GetSyncResponse {
    /**
     * Unique identifier of the synchronization operation.
     *
     * @generated from protobuf field: string sync_id = 1
     */
    syncId: string;
    /**
     * Current status of the synchronization operation.
     *
     * @generated from protobuf field: store.v1.SyncStatus status = 2
     */
    status: SyncStatus;
    /**
     * URL of the remote Directory node being synchronized from.
     *
     * @generated from protobuf field: string remote_directory_url = 3
     */
    remoteDirectoryUrl: string;
    /**
     * Timestamp when the synchronization operation was created in the RFC3339 format.
     * Specs: https://www.rfc-editor.org/rfc/rfc3339.html
     *
     * @generated from protobuf field: string created_time = 4
     */
    createdTime: string;
    /**
     * Timestamp of the most recent status update for this synchronization in the RFC3339 format.
     *
     * @generated from protobuf field: string last_update_time = 5
     */
    lastUpdateTime: string;
}
/**
 * DeleteSyncRequest specifies which synchronization to delete.
 *
 * @generated from protobuf message store.v1.DeleteSyncRequest
 */
export interface DeleteSyncRequest {
    /**
     * Unique identifier of the synchronization operation to delete.
     *
     * @generated from protobuf field: string sync_id = 1
     */
    syncId: string;
}
/**
 * DeleteSyncResponse
 *
 * @generated from protobuf message store.v1.DeleteSyncResponse
 */
export interface DeleteSyncResponse {
}
/**
 * @generated from protobuf message store.v1.RequestRegistryCredentialsRequest
 */
export interface RequestRegistryCredentialsRequest {
    /**
     * Identity of the requesting node
     * For example: spiffe://example.org/service/foo
     *
     * @generated from protobuf field: string requesting_node_id = 1
     */
    requestingNodeId: string;
}
/**
 * @generated from protobuf message store.v1.RequestRegistryCredentialsResponse
 */
export interface RequestRegistryCredentialsResponse {
    /**
     * Success status of the credential negotiation
     *
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * Error message if negotiation failed
     *
     * @generated from protobuf field: string error_message = 2
     */
    errorMessage: string;
    /**
     * URL of the remote Registry being synchronized from.
     *
     * @generated from protobuf field: string remote_registry_url = 3
     */
    remoteRegistryUrl: string;
    /**
     * Registry credentials (oneof based on credential type)
     *
     * @generated from protobuf oneof: credentials
     */
    credentials: {
        oneofKind: "basicAuth";
        /**
         * @generated from protobuf field: store.v1.BasicAuthCredentials basic_auth = 4
         */
        basicAuth: BasicAuthCredentials; // CertificateCredentials certificate = 5;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Supporting credential type definitions
 *
 * @generated from protobuf message store.v1.BasicAuthCredentials
 */
export interface BasicAuthCredentials {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * SyncStatus enumeration defines the possible states of a synchronization operation.
 *
 * @generated from protobuf enum store.v1.SyncStatus
 */
export enum SyncStatus {
    /**
     * Default/unset status - should not be used in practice
     *
     * @generated from protobuf enum value: SYNC_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Sync operation has been created but not yet started
     *
     * @generated from protobuf enum value: SYNC_STATUS_PENDING = 1;
     */
    PENDING = 1,
    /**
     * Sync operation is actively discovering and transferring objects
     *
     * @generated from protobuf enum value: SYNC_STATUS_IN_PROGRESS = 2;
     */
    IN_PROGRESS = 2,
    /**
     * Sync operation encountered an error and stopped
     *
     * @generated from protobuf enum value: SYNC_STATUS_FAILED = 3;
     */
    FAILED = 3,
    /**
     * Sync operation has been marked for deletion but cleanup not yet started
     *
     * @generated from protobuf enum value: SYNC_STATUS_DELETE_PENDING = 4;
     */
    DELETE_PENDING = 4,
    /**
     * Sync operation has been successfully deleted and cleaned up
     *
     * @generated from protobuf enum value: SYNC_STATUS_DELETED = 5;
     */
    DELETED = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateSyncRequest$Type extends MessageType<CreateSyncRequest> {
    constructor() {
        super("store.v1.CreateSyncRequest", [
            { no: 1, name: "remote_directory_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSyncRequest>): CreateSyncRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteDirectoryUrl = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSyncRequest): CreateSyncRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_directory_url */ 1:
                    message.remoteDirectoryUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_directory_url = 1; */
        if (message.remoteDirectoryUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteDirectoryUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.CreateSyncRequest
 */
export const CreateSyncRequest = new CreateSyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSyncResponse$Type extends MessageType<CreateSyncResponse> {
    constructor() {
        super("store.v1.CreateSyncResponse", [
            { no: 1, name: "sync_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSyncResponse>): CreateSyncResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSyncResponse): CreateSyncResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sync_id */ 1:
                    message.syncId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSyncResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sync_id = 1; */
        if (message.syncId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syncId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.CreateSyncResponse
 */
export const CreateSyncResponse = new CreateSyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSyncsRequest$Type extends MessageType<ListSyncsRequest> {
    constructor() {
        super("store.v1.ListSyncsRequest", [
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListSyncsRequest>): ListSyncsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListSyncsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSyncsRequest): ListSyncsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                case /* optional uint32 offset */ 3:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSyncsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        /* optional uint32 offset = 3; */
        if (message.offset !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.ListSyncsRequest
 */
export const ListSyncsRequest = new ListSyncsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSyncsItem$Type extends MessageType<ListSyncsItem> {
    constructor() {
        super("store.v1.ListSyncsItem", [
            { no: 1, name: "sync_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["store.v1.SyncStatus", SyncStatus, "SYNC_STATUS_"] },
            { no: 3, name: "remote_directory_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListSyncsItem>): ListSyncsItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncId = "";
        message.status = 0;
        message.remoteDirectoryUrl = "";
        if (value !== undefined)
            reflectionMergePartial<ListSyncsItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSyncsItem): ListSyncsItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sync_id */ 1:
                    message.syncId = reader.string();
                    break;
                case /* store.v1.SyncStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string remote_directory_url */ 3:
                    message.remoteDirectoryUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSyncsItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sync_id = 1; */
        if (message.syncId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syncId);
        /* store.v1.SyncStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string remote_directory_url = 3; */
        if (message.remoteDirectoryUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remoteDirectoryUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.ListSyncsItem
 */
export const ListSyncsItem = new ListSyncsItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSyncRequest$Type extends MessageType<GetSyncRequest> {
    constructor() {
        super("store.v1.GetSyncRequest", [
            { no: 1, name: "sync_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSyncRequest>): GetSyncRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSyncRequest): GetSyncRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sync_id */ 1:
                    message.syncId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sync_id = 1; */
        if (message.syncId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syncId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.GetSyncRequest
 */
export const GetSyncRequest = new GetSyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSyncResponse$Type extends MessageType<GetSyncResponse> {
    constructor() {
        super("store.v1.GetSyncResponse", [
            { no: 1, name: "sync_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["store.v1.SyncStatus", SyncStatus, "SYNC_STATUS_"] },
            { no: 3, name: "remote_directory_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "last_update_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSyncResponse>): GetSyncResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncId = "";
        message.status = 0;
        message.remoteDirectoryUrl = "";
        message.createdTime = "";
        message.lastUpdateTime = "";
        if (value !== undefined)
            reflectionMergePartial<GetSyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSyncResponse): GetSyncResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sync_id */ 1:
                    message.syncId = reader.string();
                    break;
                case /* store.v1.SyncStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string remote_directory_url */ 3:
                    message.remoteDirectoryUrl = reader.string();
                    break;
                case /* string created_time */ 4:
                    message.createdTime = reader.string();
                    break;
                case /* string last_update_time */ 5:
                    message.lastUpdateTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSyncResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sync_id = 1; */
        if (message.syncId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syncId);
        /* store.v1.SyncStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string remote_directory_url = 3; */
        if (message.remoteDirectoryUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remoteDirectoryUrl);
        /* string created_time = 4; */
        if (message.createdTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdTime);
        /* string last_update_time = 5; */
        if (message.lastUpdateTime !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.lastUpdateTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.GetSyncResponse
 */
export const GetSyncResponse = new GetSyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSyncRequest$Type extends MessageType<DeleteSyncRequest> {
    constructor() {
        super("store.v1.DeleteSyncRequest", [
            { no: 1, name: "sync_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSyncRequest>): DeleteSyncRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteSyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSyncRequest): DeleteSyncRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sync_id */ 1:
                    message.syncId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sync_id = 1; */
        if (message.syncId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syncId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.DeleteSyncRequest
 */
export const DeleteSyncRequest = new DeleteSyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSyncResponse$Type extends MessageType<DeleteSyncResponse> {
    constructor() {
        super("store.v1.DeleteSyncResponse", []);
    }
    create(value?: PartialMessage<DeleteSyncResponse>): DeleteSyncResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteSyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSyncResponse): DeleteSyncResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSyncResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.DeleteSyncResponse
 */
export const DeleteSyncResponse = new DeleteSyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestRegistryCredentialsRequest$Type extends MessageType<RequestRegistryCredentialsRequest> {
    constructor() {
        super("store.v1.RequestRegistryCredentialsRequest", [
            { no: 1, name: "requesting_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestRegistryCredentialsRequest>): RequestRegistryCredentialsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestingNodeId = "";
        if (value !== undefined)
            reflectionMergePartial<RequestRegistryCredentialsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestRegistryCredentialsRequest): RequestRegistryCredentialsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string requesting_node_id */ 1:
                    message.requestingNodeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestRegistryCredentialsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string requesting_node_id = 1; */
        if (message.requestingNodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestingNodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.RequestRegistryCredentialsRequest
 */
export const RequestRegistryCredentialsRequest = new RequestRegistryCredentialsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestRegistryCredentialsResponse$Type extends MessageType<RequestRegistryCredentialsResponse> {
    constructor() {
        super("store.v1.RequestRegistryCredentialsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remote_registry_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "basic_auth", kind: "message", oneof: "credentials", T: () => BasicAuthCredentials }
        ]);
    }
    create(value?: PartialMessage<RequestRegistryCredentialsResponse>): RequestRegistryCredentialsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.errorMessage = "";
        message.remoteRegistryUrl = "";
        message.credentials = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RequestRegistryCredentialsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestRegistryCredentialsResponse): RequestRegistryCredentialsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                case /* string remote_registry_url */ 3:
                    message.remoteRegistryUrl = reader.string();
                    break;
                case /* store.v1.BasicAuthCredentials basic_auth */ 4:
                    message.credentials = {
                        oneofKind: "basicAuth",
                        basicAuth: BasicAuthCredentials.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).basicAuth)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestRegistryCredentialsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        /* string remote_registry_url = 3; */
        if (message.remoteRegistryUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remoteRegistryUrl);
        /* store.v1.BasicAuthCredentials basic_auth = 4; */
        if (message.credentials.oneofKind === "basicAuth")
            BasicAuthCredentials.internalBinaryWrite(message.credentials.basicAuth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.RequestRegistryCredentialsResponse
 */
export const RequestRegistryCredentialsResponse = new RequestRegistryCredentialsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicAuthCredentials$Type extends MessageType<BasicAuthCredentials> {
    constructor() {
        super("store.v1.BasicAuthCredentials", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BasicAuthCredentials>): BasicAuthCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<BasicAuthCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicAuthCredentials): BasicAuthCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicAuthCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message store.v1.BasicAuthCredentials
 */
export const BasicAuthCredentials = new BasicAuthCredentials$Type();
/**
 * @generated ServiceType for protobuf service store.v1.SyncService
 */
export const SyncService = new ServiceType("store.v1.SyncService", [
    { name: "CreateSync", options: {}, I: CreateSyncRequest, O: CreateSyncResponse },
    { name: "ListSyncs", serverStreaming: true, options: {}, I: ListSyncsRequest, O: ListSyncsItem },
    { name: "GetSync", options: {}, I: GetSyncRequest, O: GetSyncResponse },
    { name: "DeleteSync", options: {}, I: DeleteSyncRequest, O: DeleteSyncResponse },
    { name: "RequestRegistryCredentials", options: {}, I: RequestRegistryCredentialsRequest, O: RequestRegistryCredentialsResponse }
]);
