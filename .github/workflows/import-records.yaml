name: Import MCP Records

on:
  workflow_dispatch:
    inputs:
      import_config:
        description: 'JSON configuration for imports (list of filter objects) or path to file'
        required: false
        default: '.github/workflows/scripts/import-records.json'
      dry_run:
        description: 'Run in dry-run mode'
        type: boolean
        default: false
      rate_limit:
        description: 'LLM API requests per minute (to avoid rate limit errors)'
        type: number
        default: 2
      sign:
        description: 'Sign records after pushing (uses OIDC)'
        type: boolean
        default: true
  schedule:
    - cron: '0 0 * * *'

jobs:
  import-mcp:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for OIDC signing with Sigstore
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup dirctl
        uses: ./.github/actions/setup-dirctl

      - name: Create Enricher Config
        run: |
          cat <<'EOF' > mcphost_ci.json
          {
            "mcpServers": {
              "dir-mcp-server": {
                "command": "dirctl",
                "args": [
                  "mcp",
                  "serve"
                ],
                "env": {
                  "OASF_API_VALIDATION_SCHEMA_URL": "https://schema.oasf.outshift.com",
                  "AZURE_RESOURCE_NAME": "phoenix-project-agents",
                  "AZURE_API_VERSION": "2024-10-21",
                  "AZURE_API_KEY": "${AZURE_OPENAI_API_KEY}",
                  "AZURE_OPENAI_BASE_URL": "${AZURE_OPENAI_ENDPOINT}"
                }
              }
            },
            "model": "azure:gpt-4o"
          }
          EOF

      - name: Import MCP Records
        env:
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          IMPORT_CONFIG: ${{ inputs.import_config || '.github/workflows/scripts/import-records.json' }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
          RATE_LIMIT: ${{ inputs.rate_limit || '2' }}
          SIGN: ${{ inputs.sign || 'false' }}
        run: |
          # Determine if IMPORT_CONFIG is a file path or direct JSON content
          if [ -f "$IMPORT_CONFIG" ]; then
            echo "Loading config from file: $IMPORT_CONFIG"
            CONFIG_CONTENT=$(cat "$IMPORT_CONFIG")
          else
            echo "Loading config from input string"
            CONFIG_CONTENT="$IMPORT_CONFIG"
          fi

          # Build optional flags
          DRY_RUN_FLAG=""
          if [[ "${DRY_RUN,,}" == "true" ]]; then
             DRY_RUN_FLAG="--dry-run"
          fi

          SIGN_FLAG=""
          if [[ "${SIGN,,}" == "true" ]]; then
             SIGN_FLAG="--sign"
          fi

          # base command array with rate limiting and debug enabled
          BASE_CMD=(dirctl import --type=mcp --url=https://registry.modelcontextprotocol.io/v0.1 --enrich --enrich-config=mcphost_ci.json --enrich-rate-limit="$RATE_LIMIT" --force --debug)
          if [ -n "$DRY_RUN_FLAG" ]; then
            BASE_CMD+=("$DRY_RUN_FLAG")
          fi
          if [ -n "$SIGN_FLAG" ]; then
            BASE_CMD+=("$SIGN_FLAG")
          fi

          # Get array length using jq
          LENGTH=$(echo "$CONFIG_CONTENT" | jq 'length')

          if [ -z "$LENGTH" ] || [ "$LENGTH" = "null" ]; then
             echo "Error: Invalid JSON configuration or not an array"
             exit 1
          fi

          for (( i=0; i<$LENGTH; i++ )); do
            echo "--- Processing Entry $((i+1)) ---"

            # Extract values using jq
            SEARCH=$(echo "$CONFIG_CONTENT" | jq -r ".[$i].search // empty")
            VERSION=$(echo "$CONFIG_CONTENT" | jq -r ".[$i].version // empty")
            UPDATED_SINCE=$(echo "$CONFIG_CONTENT" | jq -r ".[$i].updated_since // empty")

            # Build entry-specific arguments
            ENTRY_CMD=("${BASE_CMD[@]}")

            if [ -n "$SEARCH" ]; then
              ENTRY_CMD+=(--filter="search=$SEARCH")
            fi
            if [ -n "$VERSION" ]; then
              ENTRY_CMD+=(--filter="version=$VERSION")
            fi
            if [ -n "$UPDATED_SINCE" ]; then
              ENTRY_CMD+=(--filter="updated_since=$UPDATED_SINCE")
            fi

            echo "Running: ${ENTRY_CMD[*]}"
            "${ENTRY_CMD[@]}"
          done
